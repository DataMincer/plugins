<?php

namespace DataMincerPlugins\Fields;

use DataMincerCore\Plugin\PluginFieldBase;

/**
 * @property bool failsafe
 * @property string path
 * @property string remote
 */
class GitUrl extends PluginFieldBase {

  protected static $pluginId = 'giturl';

  protected $regexps = [];

  public function initialize() {
    parent::initialize(); // TODO: Change the autogenerated stub
    $this->regexps = [
      // HTTPS
      '~^(https://.+)(\w+/.+)\.git$~' => function($matches) {
        return $matches[1] . '/' . $matches[2];
      },
      // SSH
      '~^.+@([^:]+):(\w+/.+)\.git$~' => function($matches) {
        return 'https://' . $matches[1] . '/' . $matches[2];
      },
    ];
  }

  function getValue($data) {
    $path = $this->resolveParam($data, $this->path);
    $remote = $this->resolveParam($data, $this->remote);
    $path = $this->_fileManager->resolveUri($path);
    if (empty($path)) {
      $path = '.';
    }
    $cmd = 'git --git-dir=' .escapeshellarg($path . '/.git') . ' config --get remote.' . $remote . '.url';
    $result = exec($cmd, $output, $return);
    if ($return !== 0) {
      if (!$this->failsafe) {
        $this->error("Got error while executing command:\n\t$cmd\n\tReturn code: $return");
      }
      else {
        return "";
      }
    }
    $return = NULL;
    foreach ($this->regexps as $regexp => $func) {
      if (preg_match($regexp, $result, $matches)) {
        $return = $func($matches);
        break;
      }
    }
    return $return;
  }

  static function getSchemaChildren() {
    return parent::getSchemaChildren() + [
        'failsafe' => [ '_type' => 'boolean', '_required' => FALSE ],
        'path' => [ '_type' => 'text', '_required' => FALSE ],
        'remote' => [ '_type' => 'text', '_required' => FALSE ],
      ];
  }

  static function defaultConfig($data = NULL) {
    return [
        'failsafe' => FALSE,
        'path' => '',
        'remote' => 'origin',
      ] + parent::defaultConfig($data);
  }
}
